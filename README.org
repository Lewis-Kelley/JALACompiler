* Introduction
This is a compiler made for the Computer Architecture I CPU project. The intention is for the program to read a given C file, parse it, and create a new assembly code file. This assembly code is custom made, so it probably won't make sense without the manual. Note that the processor is stack based, so many of the commands are really simple.

This program takes an input of a c file on the command line (doesn't necessarily need the .c suffix) and will output a new file appending .asm to the input file's name.

There are some debug print statements that can be enabled at compile-time using a -D DEBUG tag when using gcc. Note that this is the default in the Makefile. Once the project nears completion, I will remove the tag from the file.

* Instructions
  1. Write a C file that follows the known limitations (see below).
  2. Compile it using your favorite C compiler (mine is gcc) and debug it there. This program won't check for your mistakes.
  3. In a shell, =cd= into this directory and type =make=.
  4. =./JALACompiler <filename>= will run the program and output a new =<filename>.asm= file. Enjoy!

* Known Limitations
- This program is *not* a syntax checker. This program *assumes* that the code you have provided can be compiled without errors using gcc or the like. If you pass it an invalid C file, the program may either crash or quietly generate a non-functioning assembly program. /Please/, compile with gcc before sending the file into this program.
- Each expression must be on its own line. You are not allowed, for instance, to do something like this:
  #+BEGIN_SRC c
  //ERROR: Only one instruction is allowed per line.
  int i = 0; i++;
  #+END_SRC c
- Each block header (if, function, for loop, etc.) must also be on their own line. Examples:
  #+BEGIN_SRC c
  //ERROR: Can't put an instruction on the same line as a block header.
  if(i == 0) { i++; }
  
  //OK
  if(i == 0) {
    i++;
  }
  #+END_SRC c
- You /must/ use curly braces for each code block. Even if the block only lasts for one line, you have to have the curly braces.
  Also, don't put the =}= on the same line as an instruction. This probably means that else statements must be written a little odd. Check with me once I have it implemented. Examples:
  #+BEGIN_SRC c
  //Valid
  if ( i ==0){
    i = 2;
  }
  else {
    i = 3;
  }
  
  //Invalid: Curly brace on line with instruction
  if ( i ==0){
    i = 2; }
    
  //Probably Invalid: else on same line as }
  if ( i ==0){
    i = 2;
  } else {
    i = 3;
  }
  #+END_SRC
- Logical statements (&&, ||, !) might not work. I haven't chosen whether or not to do them. If I choose any one in particular to do, I'll probably do ||, since that is the one which would be hardest to do without.
- The only legal variable type is =int=. The processor will only be able to handle these, so there really is no reason to allow any others.
  Functions can, however, return either =int= or =void=. Maybe =int*= will be implemented, but don't hold your breath.
- All code structures except switch statements should work eventually, but I'll try to get them working in order of functions, if's, while's, for's, and finally do-while's.
- Block comments (=/**/=) won't work, but single-line comments (=//=) will work fine.
- Function previews are not allowed. This means that every function must be defined once and only once and only above the earliest time it is called in the code. This means definitions like:
  #+BEGIN_SRC c
  //Not allowed. You need to define the whole function.
  int add(int, int);
  #+END_SRC
- Preprocessor instructions (a.k.a. # instructions) will not be available. If there is time near the end, I may handle #define, #include "additionalFile.c", and #ifdef #endif in that order. There will be no including library files, since those are way too complicated.
- Variable names have to be entirely alphanumeric, meaning no underscores or dashes. Just like standard C, they also cannot start with a number. I may expand this eventually, bt it's just easier this way.
- Modulus is not a valid operand, since we really don't have a way to deal with that effectively in assembly.
